## 📍 4장 - 변수

## 4-1. 변수란 무엇인가? 왜 필요한가?

- 변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름 (즉, **값의 위치를 가리키는 상징적인 이름**)

  - 메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류 발생시킬 가능성 높음

- 변수 이름 (변수명), 변수 값, 할당(대입, 저장) 등

## 4-2. 식별자

- **식별자 = 변수 이름** = 어떤 값을 구별해서 식별할 수 있는 고유한 이름

- 식별자는 값이 아닌 메모리 주소를 기억! (식별자를 메모리 주소에 붙인 이름이라고도 말할 수 있음)

### 4-3. 변수 선언

- **변수 선언** : 변수를 생성하는 것

- **var, let, const** 키워드 사용

- JS 엔진의 변수 선언 방법

1. **선언 단계** : 변수 이름을 등록해서 JS 엔진에 변수의 존재를 알림
2. **초기화 단계** : 값을 저장하기 위한 메모리 공간 확보 & 암묵적으로 undefined를 할당해 초기화함.

### ❗️ var

- 선언 단계와 초기화 단계가 동시에 진행됨.
  `var score;`

### 4-4. 변수 선언의 실행 시점과 변수 호이스팅

#### 예제 04-05 - 변수 선언보다 먼저 참조한 경우

```
console.log(score); // undefined
var score; // 변수 선언문
```

- `undefined` 출력 (ReferenceError 발생 ❌)
- 자바스크립트 코드는 **한 줄씩 순차적으로 실행됨**
- `console.log(score)` 실행 시점에는 `score`가 **선언되기 전**이지만 **에러가 아닌 `undefined` 출력**

> **변수 선언은 실행(runtime) 시점이 아닌, 그 이전 "평가 단계"에서 먼저 처리**되기 때문

---

### 자바스크립트 실행 원리

1. 실행 전, **소스코드 평가 단계**를 먼저 거침
2. 이때 자바스크립트 엔진은:

   - 변수 선언, 함수 선언 등 **모든 선언문을 먼저 처리**
   - 선언 외의 코드는 남겨둠

3. 그 후에 **런타임에서 한 줄씩 순차적으로 코드 실행**

- 📌 `var` 선언은 평가 단계에서 **호이스팅**되어, 선언 전 참조에도 **에러 없이 `undefined` 반환**

  > 실행 순서는 순차적이지만, **선언은 먼저 처리**됨

- **변수 호이스팅** : 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 JS의 고유 특징

### 4-5. 값의 할당

`var score = 80;` 변수 선언과 값의 할당을 동시에

- 위와 같이 하나의 문으로 단축 표현해도 JS 엔진은 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행함.

‼️ **변수 선언과 값의 할당의 실행 시점은 다름!!**

- **변수 선언** : 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행됨
- **값의 할당** : 소스코드가 순차적으로 실행되는 시점인 런타임에 실행됨

```
console.log(score); // undefined

var score = 80; // 변수 선언과 값의 할당

console.log (score); // 80
```

### 4-6. 값의 재할당

- 이미 할당되어 있는 변수에 새로운 값을 또 다시 할당
- **var** 키워드로 선언한 변수는 값 재할당 가능
- **상수** 는 값 재할당 불가

### 4-7. 식별자 네이밍 규칙

- 카멜 케이스(camelCase) : `var firstName;`

- 스네이크 케이스(snake_case) : `var first_name;`

- 파스칼 케이스(PascalCase) : `var FirstName;`

- 헝가리언 케이스(typeHungarianCase)
  - `var strFirstName;  // type + identifier`
  - `var $elem = document.getElementById('myId');  // DOM 노드`

## 📍 5장 - 표현식과 문

### 5-1. 값

- **값(value)** : 식(표현식)이 평가되어 생성된 결과
- **변수** : 하나의 **값**을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
- 값을 생성할 수 있는 방법
  - 10 + 20 (식으로 생성)
  - 3 (리터럴로 생성)

### 5-2. 리터럴

- **리터럴** : 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

ex. 숫자 리터럴 `3` / null 리터럴 `null` / 객체 리터럴 `{name : "lee" , address : "Seoul}`

### 5-3. 표현식

- 표현식 : 값으로 평가될 수 있는 문 (statement). 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조함.

```
// 리터럴 표현식
10
'Hello'

// 식별자 표현식(선언이 이미 존재한다고 가정)
sum
person.name
arr[1]

// 연산자 표현식
10 + 20
sum = 10
sum !== 10

// 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
square()
person.getName()
```

- ‼️ **값으로 평가될 수 있는 문은 모두 표현식** 이다.

### 5-4. 문

- **statement** : 프로그램을 구성하는 기본 단위이자 최소 실행 단위

`var sum = 1 + 2 ;`

- var, sum, =, 1, +, 2, ; 는 모두 **토큰**
- **문은 여러 토큰으로 구성된다.**

### 5-6. 표현식인 문과 표현식이 아닌 문

- 구분할 수 있는 가장 간단한 방법 : **변수에 할당해보기**
  - 표현식인 문 : 값으로 평가되므로 변수에 할당 가능
  - 표현식이 아닌 문 : 값으로 평가X -> 변수에 할당시 에러 발생

```
// 변수 선언문은 표현식이 아닌 문이다.
var x;

// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.
x = 100;
```

#### 💡 표현식인 문은 값처럼 사용할 수 있다

```
var foo = x = 100;
console.log(foo); // 100
```

할당문을 값처럼 변수에 할당했다. 표현식인 문인 할당문은 할당한 값으로 평가된다. **즉, x = 100은 x 변수에 할당한 값 100으로 평가된다.** 따라서 foo 변수에는 100이 할당된다.

## 📍 6장 - 데이터 타입

## 📍 7장 - 연산자

## 📍 8장 - 제어문

## 📍 9장 - 타입 변환과 단축 평가
