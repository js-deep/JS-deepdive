# 4장 변수

**❓ 자바스크립트에서 개발자의 직접적인 메모리 제어를 허용하지 않는 이유**

- 메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류를 발생시킬 가능성이 높은 매우 위험한 일이다.만약 실수로 운영체제가 사용하고 있는 값을 변경하면 시스템을 멈추게 하는 치명적인 오류가 발생할 수 있어서

**자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행한다.**

- 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
- 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화 한다.

```js
console .log(score); // undefined
var score; // 1 번수 선언
score = 80 ; // 2 값의 할당
console.log(score); // 80

var score = 80;   // 하나의 문으로 단축해도 선언과 할당 각각의 문으로 실행됨
```
- 변수 선언은 런타임 이전에 먼저 실행되고 값의 할당(1)은 런타임에 실행된다.
- 따라서 `score` 변수에 값을 할당히는 시점(2) 에는 이미 변수 선언이 완료된 상태이며 이미 `undefined`로 초기화되어 있다.
- 따라서 `score` 변수에 값을 할당하면 `score` 변수의 값은 `undefined` 에서 새롭게 할당한 숫자 값 80으로 변경(재할당)된다.

**호이스팅**

- 키워드(let, const, var, function, function*, class)를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등)가 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

**식별자 네이밍 규칙**

> 변수 선언에 별도의 주석이 필요하다면 변수의 존재 목적을 명확히 드러내지 못하는 것이다.

# 5장 값

- **값value 은 식(표현식expression)이 평가되어 생성된 결과**
- 모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장된다.
    
    메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다. 예를 들어, 메모리에 저장된 값 0100 0001을 숫자로 해석하면 65지만 문자로 해석하면 ’ A ’다.
    

**문**과 **표현식**을 구별하고 해석할 수 있다면 자바스크립트 엔진의 입장에서 코드를 읽을 수 있고 실행 결과를 예측하는 데 도움이 된다.

### 표현식

값으로 평가될 수 있는 문

### 문

문은 프로그램을 구성한는 기본단위이자 최소 실행 단위

- 선언문, 할당문, 조건문, 반복문 등
    
    ```js
    // 변수 선언문
    var x;
    // 할당문
    x = 5;
    // 함수 선언문
    function foo () {}
    // 조건문
    if (x > 1) { console .log(x) ;}
    // 반복문
    for ( var i = 0; i < 2; i ++ ) { console. log(i); }
    ```
    

> 표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것
> 

# 6장 데이터 타입

**필요성**

- 값을 저장 할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론 type inference) 된다. 그리고
재할당 의해 변수의 타입은 언제든지 통적으로 변할수 있다. 이러한 특징을 통적 타이핑dynamic typing 이라하며, 자바 스크립트를 정적 타입 언어와 구별하기 위해 동적 타업 언어라 한다.

# 7장 연산자

### Object.is 메서드

- 앞에서 살펴본 바와 같이 동둥 비교 연산지 〈==)와 일치 비교 연산지{===)는 +0과 -0을 동일하다 고 펑가한다. 또한 동일한 값인 NaN과 NaN을 비교하언 다른 값이라고 평가한다.
- ES6에서 도입된 Object.is 메서드는 다음과 같이 예측 가능한 정확한 비교 결과를 반환한다. 그 외에는 일치 비교 연산재===)와 동일하게 동작한다.
    
    ```js
    -0 === +0 ; // - true
    Object . is( -0 , +0 ); // - false
    NaN === NaN ; // - false
    Object. is( NaN, NaN) ; // - true
    ```


### typeof 연산자

typeof 연산자로 null 값을 연산해 보면 ”null"이 아닌 “ object ”를 반환한다는 데 주의하자. 이것은 자바스크립트의 첫 번째 버전의 버그다.  하지만 기존 코드에 영향을 줄 수 있기 때문에 아직까지 수정되지 못하고 있다. 

따라서 값이 null 타입인지 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용하자.

```jsx
var foo = null ;

typeof foo === null ; // false

foo === null ; // true
```

또 하나 주의해야 할 것이 있다. 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 undefined를 반환한다.

```js
// undeclared 식별자릎 선언한 적이 없다.
typeof undeclared; // undefined
```

# 8장 제어문

# 9장 타입 변환과 단축 평가

**Falsy 값**

- false
- undefined
- null
- 0, -0
- NaN
- ‘’(빈 문자열)

> Falsy 값 외의 모든 값은 모두 true로 평가되는 Truthy 값이다.
> 

**널 병합 연산자: ??**

**논리합 연산자: ||**

**논리곱 연산자: &&**

**옵셔널 체이닝: ?.**
